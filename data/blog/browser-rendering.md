---
title: 브라우저 렌더링 비교
date: 2024-11-20
category: Web
thumbnail: rendering.webp
---

### 목차

- [1. CSR 렌더링](#1-csr-렌더링)
- [2. SSR 렌더링](#2-ssr-렌더링)
  - [SSR이 적합한 경우](#ssr이-적합한-경우)
  - [SSR 방식의 장점](#ssr-방식의-장점)
  - [SSR 방식의 단점](#ssr-방식의-단점)
  - [SSR의 핵심 원칙](#ssr의-핵심-원칙)
- [3. SSG 렌더링](#3-ssg-렌더링)
  - [SSG이 적합한 경우](#ssg이-적합한-경우)
  - [SSG의 특징](#ssg의-특징)
- [4. ISR 렌더링](#4-isr-렌더링)
  - [ISR이 적합한 경우](#isr이-적합한-경우)
  - [ISR의 특징](#isr의-특징)
- [5. 하이브리드 렌더링](#5-하이브리드-렌더링)
- [6. 비교](#6-비교)
- [7. Reference](#7-reference)

---

최근 사전 과제를 통해 **Next.js**로 프로젝트를 구현하는 상황에서, **SSR**로 구현할지 **SSG + CSR**로 구현할지 고민하게 되었습니다. 이러한 고민은 렌더링 패턴에 대한 이해가 부족하다는 자각으로 이어졌고, 이를 계기로 렌더링 패턴을 깊이 공부하고 정리해 보고자 합니다.

이 글에서는 렌더링 패턴의 종류와 각각의 장단점, **언제 어떤 렌더링 전략을 채택하는 것이 적합한지**를 다룹니다. 또한, 이를 **Next.js 프로젝트**에서 어떻게 활용할 수 있을지에 대한 실제적인 방법도 함께 살펴봅니다.

자바스크립트 + 리액트 디자인 패턴책에서는 다음과 같은 렌더링 방식들도 소개하고 있습니다:

1. **스트리밍 SSR**
2. **On-demand ISR**
3. **엣지 SSR**
4. **점진적 하이브리드 렌더링**
5. **아일랜드 아키텍처**

이 글에서는 다루지 못한 이 렌더링 방식들은 **별도의 글**에서 각각 자세히 다룰 예정입니다.

## 1. CSR 렌더링

CSR(Client Side Rendering)은 애플리케이션 로직이 클라이언트에서 실행되며, 첫 요청 시 애플리케이션 전체가 클라이언트로 로드되는 렌더링 방식입니다. 이후 클라이언트는 API 호출 등을 통해 필요한 데이터를 서버에서 가져오지만, 새로운 HTML 문서를 서버로부터 요청하지 않기 때문에 페이지 새로고침 없이 사용자 경험이 자연스럽게 이어질 수 있습니다.

CSR은 SPA(Single Page Application)와 밀접한 관련이 있습니다. CSR 방식으로 구현된 웹 애플리케이션은 주로 SPA 구조를 따르며, SPA는 하나의 HTML 파일(예: `index.html`)을 기반으로 동작합니다. React, Angular, Vue와 같은 프레임워크로 빌드된 애플리케이션에서 `index.html` 파일이 단일하게 존재하는 것은 CSR과 SPA의 공통된 특성입니다.

그러나 개발이 진행될수록 코드의 양이 증가하면서 자바스크립트 번들 크기도 커지게 됩니다. 이는 페이지의 FCP(First Contentful Paint)와 TTI(Time to Interactive)를 증가시켜 사용자 경험에 부정적인 영향을 미칠 수 있습니다. 또한, 대규모 요청 객체나 API 응답 처리가 지연되면서 의미 있는 콘텐츠가 적시에 렌더링되지 않을 가능성이 있습니다. 이러한 문제는 크롤러가 웹페이지를 색인하기 전에 발생할 수 있어 웹사이트의 SEO(Search Engine Optimization)에 부정적인 영향을 미칠 수 있습니다.

더불어, CSR 방식에서는 클라이언트에서 렌더링되는 데이터가 쉽게 노출될 수 있습니다. 예를 들어, 클라이언트 코드에 포함된 API 호출 URL, 요청 데이터, 키 값 등의 정보는 개발자 도구를 통해 확인될 수 있어 보안상 취약점이 될 수 있습니다.

다음으로 **CSR의 동작 방식**을 살펴보겠습니다.

1. 사용자가 브라우저 주소창에 URL을 입력하고 엔터를 치면, 브라우저는 HTTP 요청을 서버로 보냅니다.
2. 서버는 `index.html` 파일을 반환합니다. 이 파일은 HTML 기본 구조만 포함하며, 콘텐츠는 자바스크립트 실행 후 클라이언트에서 동적으로 생성됩니다. 초기 로딩 시 브라우저는 빈 화면처럼 보일 수 있습니다
3. 브라우저는 `index.html` 파일 안에 포함된 스타일시트(CSS)와 스크립트(JS) 파일을 요청합니다.
4. 서버는 요청받은 CSS와 JS 파일을 반환합니다. 브라우저가 이를 다운로드하고 실행하면, 자바스크립트가 동작하여 API를 호출하거나 DOM을 조작하며 화면을 렌더링합니다. 결과적으로 사용자는 완성된 페이지를 볼 수 있습니다.

다음은, Next.js에서 CSR을 설정하는 방법에 대해 알아보겠습니다.

```tsx
// Next.js 12
// 기본 동작이 CSR

// Next.js 13
'use client' // 컴포넌트 상단에 작성
```

- **Next.js 12**: CSR은 기본적으로 동작하며, 별도의 설정이 필요하지 않습니다.
- **Next.js 13**: `'use client'` 디렉티브를 사용하여 CSR을 설정할 수 있습니다.

## 2. SSR 렌더링

SSR(Server Side Rendering)은 클라이언트(브라우저)가 HTTP 요청을 보낼 때마다 서버에서 HTML 페이지를 생성하여 반환하는 렌더링 방식입니다. 이 과정에서 필요한 데이터 fetching과 콘텐츠의 HTML 생성이 서버에서 동시에 이루어집니다.

**SSR이 적합한 경우:**

1. **개인 맞춤형 데이터가 필요한 페이지:** 사용자 쿠키 정보나 요청 데이터를 기반으로 개인화된 콘텐츠를 제공해야 하는 경우.
2. **인증 상태에 따라 렌더링 여부를 결정해야 하는 페이지:** 로그인 여부, 권한 상태 등에 따라 페이지 콘텐츠를 동적으로 결정하는 경우.

**SSR 방식의 장점:**

1. **추가적인 왕복 시간 감소(FCP 감소):** CSR에서는 HTML 로드 후 추가 요청으로 자바스크립트 및 스타일시트 파일을 받아야 하지만, SSR은 초기 요청 시 완전한 HTML을 반환하여 추가적인 왕복 시간을 줄입니다.
2. **전송 데이터 최적화:** SSR은 클라이언트에 필요한 HTML만 전송하므로, CSR과 달리 대규모 자바스크립트 번들을 클라이언트로 전송할 필요가 없습니다. 이로 인해 네트워크 비용이 감소하고 초기 로딩 속도가 향상됩니다.
3. **SEO 최적화:** SSR은 클라이언트가 아닌 서버에서 HTML을 생성하므로, 검색 엔진 크롤러가 페이지 콘텐츠를 즉시 색인할 수 있습니다. 이는 CSR 방식에서 발생할 수 있는 크롤링 지연 문제를 해결하며, 검색 엔진 최적화(SEO) 성능을 크게 향상시킵니다.
4. **보안:** 서버에서 HTML을 렌더링하고 데이터를 처리하기 때문에 클라이언트로 전송되는 데이터의 노출을 최소화할 수 있습니다. 특히 민감한 데이터(API 키, 인증 정보 등)가 클라이언트에서 노출되지 않도록 보호할 수 있어 보안성이 강화됩니다.

**SSR 방식의 단점:**

1. 서버 부하 증가: 모든 요청을 독립적으로 처리하며, 서버는 각 요청마다 HTML을 새로 생성해야 합니다. 동일한 콘텐츠를 요청하는 경우에도 서버는 처음부터 다시 처리하기 때문에, 트래픽이 많은 웹사이트에서는 서버에 과부하가 걸릴 수 있습니다.

**SSR의 핵심 원칙:**

SSR의 핵심은 HTML을 서버에서 렌더링하고 클라이언트에서 다시 하이드레이션하는 데 필요한 자바스크립트를 함께 제공하는 것입니다.

<aside>
💡

**하이드레이션(Hydration)**

서버 렌더링 후 클라이언트 사이드에서 UI 컴포넌트의 상태를 재생성하는 과정

</aside>

다음으로 **SSR의 동작 방식**을 살펴보겠습니다.

1. 사용자가 브라우저 주소창에 URL을 입력하고 엔터를 치면, 브라우저는 HTTP 요청을 서버로 보냅니다.
2. 서버는 요청받은 URL에 해당하는 코드를 실행합니다. 데이터베이스에서 필요한 데이터를 읽어오거나, 외부 API와 통신하여 데이터를 가져와 HTML 을 생성합니다. (이 과정은 서버에 미리 작성된 코드를 실행하는 것을 전제로 합니다)
3. 서버에서 생성된 완성된 HTML 파일을 브라우저에게 반환합니다. 브라우저는 반환받은 HTML을 즉시 렌더링하여 사용자에게 화면을 표시합니다

다음은, Next.js에서 **SSR**을 설정하는 방법에 대해 알아보겠습니다.

```tsx
// Next.js 12
export async function getServerSideProps() {
  const res = await fetch('https://api.example.com/data')
  const data = await res.json()

  return {
    props: { data },
  }
}

// Next.js 13
export const dynamic = 'force-dynamic' // SSR 강제 설정

// fetch를 이용하여 설정하기
const res = await fetch('https://api.example.com/data', {
  next: { revalidate: 0 },
})

// or

const res = await fetch('https://api.example.com/data', {
  cache: 'no-store',
})
```

- **Next.js 12**: `getServerSideProps`을 사용합니다.
- **Next.js 13**: `dynamic: 'force-dynamic'`와 `cache: 'no-store'` 옵션을 사용하여 SSR 구현이 가능합니다.

## 3. SSG 렌더링

SSG(Static Site Generation)는 전체 페이지의 HTML을 **빌드 시점**에 미리 생성하며, 이후 변경이 필요할 경우 **다음 빌드**에서 다시 생성됩니다.

SSR과 SSG의 주요 차이점은 **렌더링 시점**에 있습니다.

- **SSR**: 요청 시점에 서버에서 HTML을 생성합니다.
- **SSG**: 빌드 시점에 HTML을 생성하여, 클라이언트 요청 시 사전 생성된 정적 파일을 반환합니다.

**SSG이 적합한 경우:**

SSG는 변경 빈도가 낮고, 정적인 콘텐츠를 제공하는 페이지에 적합합니다. (회사 소개 페이지, 블로그 및 문서 페이지와 같은 정적 콘텐츠 기반의 페이지)

**SSG의 특징:**

1. **빠른 응답 시간(빠른 FCP):** SSG는 HTML을 빌드 시점에 미리 생성하므로, SSR과 달리 페이지 요청 시 추가적인 렌더링 작업 없이 미리 생성된 HTML 파일을 바로 응답합니다. 이로 인해 요청 처리 및 응답 속도가 매우 빠릅니다.
2. **정적 데이터 기반:** 모든 사용자가 동일한 데이터를 보게 되므로, **사용자별 맞춤 데이터**를 제공하는 페이지에는 적합하지 않습니다.
3. **SEO 최적화:** SSG는 빌드 시점에 HTML을 생성하기 때문에 검색 엔진 크롤러가 완성된 HTML을 쉽게 읽고 색인할 수 있습니다.
4. **보안:** SSG는 정적 파일로만 구성되어 있어 서버 측 실행 로직이 없습니다.

다음으로 **SSG의 동작 방식**을 살펴보겠습니다.

1. 개발자는 웹사이트를 빌드할 때 모든 페이지를 정적으로 생성하고, 이 HTML 파일들을 서버에 저장합니다. 페이지 콘텐츠는 빌드 시점에 고정되며, 데이터베이스 요청이나 추가적인 서버 연산 없이도 사용할 수 있습니다.
2. 사용자가 브라우저 주소창에 URL을 입력하고 엔터를 치면, 브라우저는 HTTP 요청을 서버로 보냅니다.
3. 서버는 요청받은 URL에 해당하는 미리 생성된 HTML 파일을 즉시 반환합니다. 브라우저는 반환받은 HTML을 즉시 렌더링하여 사용자에게 화면을 표시합니다

다음은, Next.js에서 SSG를 설정하는 방법에 대해 알아보겠습니다.

```tsx
// Next.js 12
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/data')
  const data = await res.json()

  return {
    props: { data },
  }
}

// Next.js 13 기본동작
export const dynamic = 'force-static' // SSG 강제 설정 (기본값이 static임)

// 동적 라우트에서 SSG 설정하기
export async function generateStaticParams() {
  const datas = await getDatas()
  return datas.map((data) => ({
    slug: data.id,
  }))
}

// fetch를 이용하여 설정하기 (Next13의 기본동작)
const res = await fetch('https://api.example.com/data', {
  cache: 'force-cache', // 빌드 시 데이터를 캐싱
})
```

- **Next.js 12**: `getStaticProps`을 사용합니다.
- **Next.js 13**: `force-static`이 기본값으로 적용되며 동적 라우트에서는 `generateStaticParams`를 사용하여 적용할 수 있습니다.

## 4. ISR 렌더링

**ISR(Incremental Static Regeneration)은 SSG(Static Site Generation)에 기반한 렌더링 방식**으로, 초기 빌드 시 정적 페이지를 생성한 뒤, 설정된 주기에 따라 페이지를 다시 생성(갱신)합니다.

ISR**가 적합한 경우:**

- **빈번히 업데이트되는 콘텐츠**: 블로그 게시물, 뉴스 사이트, 제품 카탈로그처럼 데이터가 자주 변경되지만, 사용자마다 콘텐츠가 다르지 않는 경우, ISR로 개발합니다.
- 빠른 초기 로드 필요: 초기 로딩 속도가 중요한 경우 ISR로 개발합니다.
- 실시간 갱신이 불필요한 콘텐츠: 데이터가 약간 오래되어도 큰 문제가 없는 경우에 사용합니다.

ISR**의 특징:**

1. 정적 페이지와 동적 갱신 결합: 페이지를 요청할 때마다 동적 데이터를 가져오지 않고, 미리 생성된 정적 HTML을 반환합니다. 설정된 갱신 주기(revalidate)에 따라 백그라운드에서 새로운 페이지를 생성합니다.
2. SEO 최적화: SSG처럼 정적 HTML을 반환하므로 검색 엔진 최적화(SEO)에 유리합니다.
3. 서버 부하 감소: 페이지를 요청할 때마다 데이터를 동적으로 생성하지 않으므로, 서버의 부하를 줄일 수 있습니다.
4. 백그라운드 갱신: 설정된 `revalidate` 시간 이후 첫 번째 요청이 들어오면, 서버가 새로운 HTML을 백그라운드에서 생성합니다. 사용자는 기존의 정적 HTML이 즉시 반환되므로 대기 시간이 없습니다.

다음으로 **ISR의 동작 방식**을 살펴보겠습니다.

1. 초기 요청: 사용자가 페이지를 요청하면, 서버는 미리 생성된 HTML 파일을 반환합니다 (SSG 방식과 동일)
2. 갱신 주기 초과 후 요청: 설정된 `revalidate` 시간이 초과되면, 첫 번째 요청 시 기존 페이지를 반환하면서 백그라운드에서 새로운 HTML을 생성합니다.
3. 새로운 HTML 생성 완료: 새로운 HTML 파일이 생성되면, 이후 요청부터는 갱신된 HTML 파일이 반환.

다음은, Next.js에서 ISR을 설정하는 방법에 대해 알아보겠습니다.

```tsx
// Next.js 12
export async function getStaticProps() {
  const res = await fetch('https://api.example.com/data')
  const data = await res.json()

  return {
    props: { data },
    revalidate: 10, // 10초마다 페이지 재생성
  }
}

// Next.js 13
export const revalidate = 10 // ISR 설정

// fetch를 이용하여 설정하기
const res = fetch('https://api.example.com/data', {
  next: { revalidate: 3000 },
})
```

- **Next.js 12**: `revalidate` 옵션을 사용합니다.
- **Next.js 13**: `next: { revalidate: 3000 }` 옵션 또는 `revalidate` 변수를 사용합니다.

## 5. 하이브리드 렌더링

여러 가지 렌더링 방식을 결합하는 방법으로, 어떤 상황에서든 최적의 결과를 제공하기 위한 방법입니다. 하이브리드 렌더링을 잘 사용하게된다면, 서버가 필요 없는 SPA의 이점을 제공하면서도, 페이지 새로고침 없이 네비게이션할 수 있어 정적 렌더링의 문제를 피할 수 있습니다.

중요한 점은, SPA의 사용을 멀리하는 것이 아니라, SPA를 사용하지 말라는 것이 아니라, SPA의 틀에 갇히는 것에서 벗어나 각 페이지에 맞는 렌더링 모드를 유연하게 사용한하는 것입니다.

사용자의 데이터가 개별적인지, 데이터의 변경 주기는 어느정도여야 하는지 등의 정보를 고려하여 어떤 렌더링을 채택할지에 대해

## 6. 비교

| 렌더링 방식 | 설명                                        | 특징                               | 장점 | 단점 | 사용 사례 |
| ----------- | ------------------------------------------- | ---------------------------------- | ---- | ---- | --------- |
| CSR         | 클라이언트(브라우저)에서 모든 렌더링을 수행 | - 초기 요청 시 HTML과 JS 번들 로드 |

- 클라이언트에서 JS로 뷰를 생성
- SPA 구현에 적합 | - 페이지 전환 시 서버 요청 없음
- 인터렉티브한 UI 구현에 적합 | - 초기 로딩 속도 느림
- SEO에 불리함
- 보안에 취약함 | 소설 미디어,
  대화형 애플리케이션, 게임 |
  | SSR | 서버에서 HTML을 생성해 클라이언트로 전송 | - 요청마다 서버에서 HTML 생성
- 서버에서 데이터 fetching
- 초기 로딩 빠름 | - SEO에 유리
- 서버에서 생성된 HTML 제공으로 초기 로딩 시간 단축
- 보안이 뛰어남
- 사용자별 데이터 적용 가능 | - 서버 부하 증가
- 트래픽이 많으면 서버 확장이 필요 | 뉴스, 블로그, SEO가 중요한 애플리케이션 |
  | SSG | 빌드 시점에 HTML 파일을 미리 생성 | - 정적 HTML 파일 생성
- 데이터가 자주 바뀌지 않는 페이지에 적합 | - 빠른 초기 로딩
- 비용 효율적
- SEO에 유리
- 보안이 뛰어남 | - 빌드 후 콘텐츠가 변경되면 재배포 필요
- 데이터가 실시간으로 자주 변경되는 애플리케이션에 부적합 | 블로그, 회사 소개, FAQ, 제품 페이지 |
  | ISR | SSG에 기반하여 설정된 주기나 특정 조건에 따라 HTML을 재생성 | - 초기 빌드 시 정적 HTML 생성
- 주기적 재생성(revalidate) 또는 On-demand 방식 지원 | - SSG의 장점을 유지하며 실시간 데이터 업데이트 가능 | - 설정된 주기나 조건에 따라 최신 데이터 제공
- 복잡한 데이터 연결은 구현이 어려울 수 있음 | 뉴스, 제품 목록, 실시간 콘텐츠가 중요한 블로그 |

## 7. Reference

[자바스크립트 + 리액트 디자인 패턴](https://m.yes24.com/Goods/Detail/129374961)
