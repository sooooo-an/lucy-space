---
title: 브라우저 렌더링 방법과 렌더링 과정 최적화 방법
date: 2024-11-20
category: Web Performance
---

### 목차

[브라우저 성능이란](#브라우저-성능이란) \
[브라우저 렌더링 방식](#브라우저-렌더링-방식) \
[업데이트 과정](#업데이트-과정) \
[Preload Scanner](#preload-scanner) \
[브라우저 성능 지표](#브라우저-성능-지표) \
[브라우저 렌더링 최적화](#브라우저-렌더링-최적화)

---

## 브라우저 성능이란

우리는 사용자 경험을 위해 성능이 좋은 애플리케이션을 만들기위해 노력한다. 그렇다면 여기서 말하는 "성능"이란 무엇을 의미할까?

성능의 정의는 상황에 따라 달라진다.

- 백엔드 관점: 초당 처리 가능한 트랜잭션 수(TPS)나 서버 응답 속도
- 프론트엔드 관점: 사용자가 화면을 얼마나 빠르게 보고 상호작용할 수 있는지

특히 프론트엔드 성능은 **눈에 보이는 속도**와 **반응 속도**로 정의될 수 있다. 사용자가 페이지를 처음 볼 때까지의 시간과, 클릭이나 스크롤 같은 사용자 행동에 빠르게 반응하는 정도가 이를 결정한다.

---

## 브라우저 렌더링 방식

브라우저는 단순한 HTML 파일을 어떻게 상호작용 가능한 인터페이스로 변환할까? \
이 과정을 **Critical Rendering Path**라고 하며, 크게 5단계로 나뉜다.

1. **HTML 파싱:** HTML을 구문 분석하고 DOM(Document Object Model) 트리로 변환한다
   이 과정에서 HTML 내부의 리소스(이미지, 스크립트, 스타일시트 등)를 발견하면 이를 네트워크로 요청하며, 다수의 HTTP 요청이 생성된다

   - 주의사항: 스크립트나 자바스크립트 파일은 HTML 파싱을 중단시킨다. (`async`, `defer` 속성을 사용하여 방지할 수 있다)

2. **CSSOM 생성:** CSS를 구문 분석하고 CSSOM 트리로 변환한다

3. **렌더 트리 생성:** DOM과 CSSOM을 렌더 트리에 결합한다
   렌더 트리는 화면에 실제로 렌더링될 요소만 포함된다.

   - 예를 들어, `head` 태그나 `display: none`스타일이 적용된 엘리먼츠는 렌더 트리에 포함되지 않는다

4. **레이아웃(Layout) 단계:** Reflow라고도 불리며, 각 요소가 화면에 어디에 위치해야 할지 계산하는 단계이다. \
   브라우저는 렌더 트리를 기반으로 뷰포트 정보를 고려하여 각 요소의 크키(width, height)와 위치(position)를 결정한다

5. **페인팅(Painting) 및 컴포지트(Composite) 단계:** 화면에 그려질 픽셀을 결정하고, 이를 실제 화면에 표시한다.

   - 페인팅(Painting): 색상, 배경, 그림자, 테두리 등 요소의 스타일을 기반으로 픽셀을 그리는 과정
   - 컴포지팅(Compositing): 여러 레이어를 결합하여 최종적으로 화면에 표시한다. 이 과정에서 GPU를 활용하여 성능을 최적화하는 최신 브라우저의 기술이 사용된다.

---

## 업데이트 과정

JavaScript가 페이지의 일부 요소를 변경하면, 브라우저는 이를 반영하기 위해 4가지 주요 단계를 거친다.

#### 브라우저 업데이트 과정

| 단계                  | 정의                        | 트리거되는 CSS 속성                               | 예시 코드                                 |
| --------------------- | --------------------------- | ------------------------------------------------- | ----------------------------------------- |
| **Recalculate Style** | 스타일 규칙 재계산          | `color`, `font-family`, `visibility`              | `element.style.color = 'red';`            |
| **Reflow (Layout)**   | 레이아웃(크기, 위치) 재계산 | `width`, `height`, `margin`, `padding`, `display` | `element.style.width = '300px';`          |
| **Repaint**           | 픽셀 데이터 다시 그림       | `background-color`, `box-shadow`, `border-color`  | `element.style.backgroundColor = 'blue';` |
| **Composite**         | GPU 레이어 결합 및 렌더링   | `transform`, `opacity`, `will-change`             | `element.style.transform = 'scale(1.5)';` |

예시:

- 색상 변경: 해당 요소에서만 Repaint가 발생
- 레이아웃 변경: 마진, 패딩, 폰트 크기 등의 변경은 해당 요소뿐만 아니라 형제 요소에도 영향을 미쳐 Reflow와 Repaint가 발생
- 전역 폰트 변경: 페이지 전체에서 Reflow와 Repaint가 발생

---

## Preload Scanner

Preload Scanner는 HTML 파싱 단계 중에 실행되는 브라우저의 중요한 기능으로, 렌더링 성능을 최적화한다.

Preload Scanner는 HTML 파싱 중 우선 순위가 높은 리소스를 탐지하고, 이를 즉시 비동기로 요청한다.
이는 HTML 파싱이 완료될 때까지 HTTP 요청을 기다리는 대신, 구문 분석과 리소스 로딩을 병렬로 처리하여 렌더링 과정을 가속화한다.

#### 동작 방식 예시

![preload Scanner](/images/posts/web-performance/preload-scanner.png)

- Preload Scanner가 없는 경우: HTML 파일에 `<script>` 태그가 끝부분에 있다고 해보자. 브라우저는 HTML 파싱이 끝날 때까지 기다렸다가 스크립트에 대한 HTTP 요청을 보낸다.
- Preload Scanner가 있는 경우: 브라우저는 HTML을 파싱하는 동안 `<script>` 태그를 발견하면, 즉시 해당 리소스에 대해 HTTP 요청을 보냅니다.
  HTML 파싱과 리소스 로딩이 병렬로 이루어지므로, 렌더링 속도가 빨라집니다.

---

## 브라우저 성능 지표

브라우저 렌더링 성능을 측정하고, Critical Rendering Path를 최적화하기 위해 다음 지표를 확인해야한다:

1. **First Contentful Paint(FCP):**
   - 화면에 첫 번째 DOM 콘텐츠(텍스트, 이미지 등)가 표시되는 시간
   - 일부 콘텐츠만 로드된 상태를 의미하며, 전체 페이지가 로드된 것은 아니다
2. **First Meaningful Paint(FMP):**
   - 사용자에게 의미 있는 콘텐츠가 화면에 표시되는 시간
   - 페이지가 최소한 사용자가 유용하다고 느낄만큼 로드된 상태를 측정한다
3. **Time to interactive(TTI):**
   - 페이지가 사용자 입력에 반응할 수 있는 상태가 되는 시간
   - 스레드가 하나만 있기 때문에 스크립트를 실행하는데 걸리는 시간이 포함된다. 따라서 스크립트가 초기 코드를 실행하는 동안 페이지에는 상호작용이 없기 때문에 해당 상호 작용 지점에 도달하는 데 걸리는 시간을 측정할 수 있게 된다.

---

## 브라우저 렌더링 최적화

Critical Rendering Path를 최적화하려면 다음과 같은 방법들을 활용할 수 있다

1. **`defer`/`async` 스크립트 사용**

   - `defer`: HTML 파싱이 완료된 후 스크립트를 실행한다
   - `async`: HTML 파싱과 스크립트 로딩을 병렬로 처리한다

2. **DOM 크기 최소화**

   - DOM의 중첩을 줄이고 간결한 구조를 유지한다
   - 시멘틱 마크업은 DOM 크기를 약간 늘릴 수 있으나, 접근성과 유지보수성을 높이는 데 중요한 역할을 한다. 따라서 과도한 최적화를 위해 시멘틱 마크업을 포기하지 않는 것이 좋다

3. **파일 크기 줄이기(압축 및 최소화)**

   - 압축: HTTP 요청으로 전달되는 파일(스크립트, 이미지 등)의 크기를 중이면 병목현상을 줄일 수 있다.
   - 최소화: 공백, 주석 등을 제거하여 파일 크기를 줄인다

4. **지연 로딩(Lazy Loading)**

   - 초기 로딩 시 필수적인 리소스만 포함하고, 추가 콘텐츠는 사용자가 필요로 할 때 로드한다

5. **하드웨어 가속 애니메이션**

   - GPU가속: `transform`과 `opacity`속성을 활용해 애니메이션을 GPU에서 처리하도록 브라우저에 지시한다

   ```css
   .animated {
     transform: translate3D(0, 0, 0);
   }
   ```

   위 코드는 브라우저에게 해당 요소를 **컴포지팅 레이어(Compositing Layer)** 로 승격시키라고 알린다. 이로 인해 애니메이션은 GPU에서 처리되어 더 부드럽고 효율적으로 작동하게된다.

   #### 합성(Compositing)

   - 3차원 공간을 사용할 때, 엘리먼츠를 레이어링 한다. 그렇기 떄문에 위의 코드를 작성하면 애니메이션이 GPU에 의해 처리된다.
   - 브라우저가 이 레이어링을 수행할 때, 애니메이션이 얼마나 복잡한 지 깨닫고 하드웨어를 가속화시킨다.
   - 이 것이 의미하는 바는 CPU 대신 GPU에서 처리하여 일반적으로 성능이 향상된다는 것이다.

   - 주의사항: `transform: translate3D(0, 0, 0)`을 모든 애니메이션에 사용하지 말 것.
